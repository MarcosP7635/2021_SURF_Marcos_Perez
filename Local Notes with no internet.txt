If each column is a spectral channel, what is each row? The first column is the wavelength in nm,
so each row is a different wavelength! Trippy. And the value is the log of intensity ratio (dB?)
6/23
FPR allows the light to propagate - Free propagation region. Ignore the gray vertical line in the 
greeen region. Silican nitride - 
Higher index in the pole and lower in the clearing. That's what allows the light to propagate. 
Waveguides are similar to optical fibers in this respect. High index guides it and low index surrounds
it! (remember from Hect). Clearing is silicon dioxide and pole is silicon nitride. Everything in Figure 
1 from Pradip's 2021 paper is silicon nitride. IRL, it's surrounded by silicon dioxide. If I ask the 
same question twice, ask Pradip to record it. Each channel is symmetrical near the peak wavelength, 
but as the transmission decreases, they become asymmetrical. The center is symmetrical, but the 
wings are not. On the edges of the AWG, the incoming (Figure 2 on the 2017 paper https://arxiv.org/abs/2106.04598. Output FPR)  
The central output channel will receive the light symmetrically from the left and right sides of the 
array. The edge channels don't have this advantage, so they see more light from one side of the array
from the other (inverse square law!). you can individually plot the peaks of each channel and the wings 
if you want!The find_peaks function is defined in scipy. There's a text file for
each channel with its transmission curve. There are two peaks in each column, one corresponding to each
spectral order. There are tinier peaks in the noise. Find main peaks, not the ones in the noise! 
That's why we define the distance to be 80% of the FSR. Look at the find_3dB_width. lam_n - lam_{n-1}.
find_peaks needs it in indices so we divide by the wavelength step size.  

You can do things yourself if pradip doesn't reply. Tomorrow go to campus maybe?
Get the first plot out with channels vs power! See if we need to change our approach.
Get your initial plots then replan!!! 

Hi Marcos, I see that you changed the find_3dB_width function to add a height = -7. That will not work. This is because, we are first converting the dB-scale transmission to linear scale in that function. See the definition of  op_power_norm_fib_lin in the following code. So -7 as the height will be inconsequential since the 'linear' values are all positive.
def find_3dB_width(lam, op_power_norm_fib, FSR):
    d_lam = (lam[len(lam)-1]-lam[0])/len(lam)
    print(d_lam)
    FSR_chunk = np.int(0.8*FSR/d_lam) # Taking 80% of the FSR as the minimum distance between the peaks
    op_power_norm_fib_lin = np.power(10.0,  op_power_norm_fib/10) # converting to linear scale for peak-width measurement
    peaks, _ = find_peaks(op_power_norm_fib_lin, distance=FSR_chunk)

Marcos Perez  11:17 AM
Thank you for the correction and I appreciate the explanation. I expect the smallest linear value to be .3 for any of the peaks, so should I use .2 as the threshold instead? Should I not use a threshold at all? I have the original Jupyter Notebook on the Github as well so I can just change that function back to the original if that's better.

Pradip Gatkine  11:18 AM
Here's the figure I could plot after the correction;
image.png 
image.png



1 reply
Today at 11:19 AMView thread

Pradip Gatkine  11:19 AM
So all the peaks are properly detected

Pradip Gatkine  11:22 AM
If you do height = 0.1 in the find_3dB_width function, then you can get all the peaks correctly, without any additional detection of sidelobes (particularly near the edges).

1 reply
Today at 11:22 AMView thread

Pradip Gatkine  11:26 AM
Also, there is another codeblock you have:
#Now we need to get the peaks!
lam = np.array(df['0'])
FSR = 20.0
op_power_norm_fib = np.array(df['1'])
peaks = find_3dB_width(lam, op_power_norm_fib, FSR)
center_nanometer = peaks[1][0]
print(peaks[1])
Here, note that you are only looking at one spectral channel (i.e. the first spectral channel), since you are using df['1']. To see the impact of an emission line on all the spectral channels , you will have to run a for loop. (edited) 
New
11:28
Here's the codeblock I used to make the plot shown above.
fig, ax = plt.subplots(figsize=(10,6))
df.plot(x='0', legend=0, ax = ax)
for i in range(1,chan_num+1):
    lam = np.array(df['0'])
    op_power_norm_fib = np.array(df[str(i)])
    FSR = 20 # nm
    peak_ind, peak_lam, peak_power, peak_width, d_lam = find_3dB_width(lam, op_power_norm_fib, FSR)
    #plt.plot(lam, op_power_norm_fib)
    #plt.plot(peak_lam, peak_power, 'b*')
    plt.plot(peak_lam, peak_power, '*')
ax.set_ylim(-60,5)
plt.show()
Note that this was done using the find_3dB_width function as shown below:
def find_3dB_width(lam, op_power_norm_fib, FSR):
    d_lam = (lam[len(lam)-1]-lam[0])/len(lam)
    print(d_lam)
    FSR_chunk = np.int(0.8*FSR/d_lam) # Taking 80% of the FSR as the minimum distance between the peaks
    op_power_norm_fib_lin = np.power(10.0, op_power_norm_fib/10) # converting to linear scale for peak-width measurement
    peaks, _ = find_peaks(op_power_norm_fib_lin, height=0.1, distance=FSR_chunk)
    #find_peaks is defind in scipy. You can use it to place the emission lines! Get the array from here
    results_half = peak_widths(op_power_norm_fib_lin, peaks, rel_height=0.5)  # rel_height = 0.5 => FWHM  (half-power beam width)
    #you can define offsets in terms of the FWHM named results_half
    return peaks, lam[peaks], op_power_norm_fib[peaks], d_lam*results_half[0], d_lam  # The zeroth element is width

Change the plots from power (arbitrary units) to dB so they're logarithmic and you can see the 
difference in each channel. This is an important distinction. Make sure to add this!

Make a rectangular grid of subplots. Keep it to the peaks of 7 channels.
2 rows and four columns. Don't need a long label (lambda_cen) is sufficient and can be 
slightly above the plot. 
State the shaped and width in the caption. 
 
ax1.text(0.08,  0.90, '$z$ = 2 $-$ 2.7', color='blue', fontsize=12, fontweight='bold', transform = ax1.transAxes)
    You can have the handles for the subplots as an array. 
    You can just assign ax1 = ax[row][col] and that will work
    You can reassign ax1 in a for loop.
    This also works as well 
    ax1 = ax[index[0]][index[1]]
    ax1.set_xscale('linear')
    ax1.set_yscale('linear')
Also there's a really compact way to assign specific attributes to each subplot
ax1 = plot_format(ax1, xlim1=11, xlim2=13, ylim1= NVVlim1, ylim2= NVVlim2, xlabel=xlabel, ylabel=ylabel) 
Just add the power for multiple lines, and you can use a for loop to do this. 